# Controllers and Request/Response

In this lesson, we’re going to continue our discussion about the _Controller,_ and explore a few more core Spring MVC annotations that come into play when building a REST API.

The relevant module you need to import when you're working with this lesson is: [controller-request-response](https://github.com/eugenp/learn-spring/tree/module8/controller-request-response)

## Overview

Particularly, in this case **we’ll focus on the _@RequestBody_ and the _@ResponseBody_ annotations**, which we can use to map the HTTP Request body and the Response body to and from a Java object, respectively.

This process is sometimes referred as serialization and deserialization, or marshalling and unmarshalling.

## Under the Hood

In order to understand these annotations, it’s critical to understand the underlying mechanism that Spring MVC uses to carry out this marshalling and unmarshalling.

Simply put, **Spring MVC reads and writes the body of the HTTP request using HTTP Message Converters**. This entire mechanism is auto-configured based on the libraries we have on the classpath. So, most of the time we’re not explicitly configuring the converters.

Still, it’s important to understand how that all works because it’s likely that we’ll have several converters working together, and we do need to know which one is actually used based on our request.

That leads into the concept of ‘Content Negotiation’, which is out of scope for this lesson here, but I’ll make sure to add a link in the lesson notes so that you can read more about how that works.

## The _HttpMessageConverter_

As we discussed, Spring configures the message converters based on the active dependencies we have in our project. For example, if we have a look at our _pom.xml_ file:

```
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

The _spring-boot-starter-web_ library we have here includes the Jackson 2 library, and therefore enables the corresponding HTTP message converter, which is _MappingJackson2HttpMessageConverter._

This converter is useful, naturally, for dealing with JSON.

## The _@RequestBody_ Annotation

If we have a look at our _ProjectController#create_ method, we'll notice that we’re using the _@RequestBody_ annotation here:

```
@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public ProjectDto create(@RequestBody ProjectDto newProject) {
  Project entity = convertToEntity(newProject);
  return this.convertToDto(this.projectService.save(entity));
}
```

**By adding the _@RequestBody_ annotation, we get access to the body of the request and deserialize that** to a _ProjectDto_ object.

We can now launch the application and check what happens when we send a request with no body:

_POST http://localhost:8080/projects_

As we can see, we’re receiving a Bad Request response with a message indicating that the application expects a _ProjectDto_ request body:

```
{
    "timestamp": "2019-08-04T18:35:47.494+0000",
    "status": 400,
    "error": "Bad Request",
    "message": "Required request body is missing: public com.baeldung.ls.web.dto.ProjectDto com.baeldung.ls.web.controller.ProjectController.create(com.baeldung.ls.web.dto.ProjectDto)",
    "path": "/projects"
}
```

We could potentially indicate this is a valid scenario if we wanted to; the annotation allows adding a _required_ parameter which we can set to _false._

With this, the application would assign a _null_ value to the object instead of retrieving a 400 response code.

Since that is not the case here, we'll focus on adding the HTTP body.

In order for the mapping to work correctly, **the JSON fields have to match the class attributes**. Naturally, this default behavior can be customized with annotations.

Let's have a look at the attributes of the _ProjectDto_ class then in order to figure out the structure of the JSON body we’ll create:

```
public class ProjectDto {

    private Long id;
    private String name;
    private LocalDate dateCreated;
    private Set<TaskDto> tasks;
    
    // ...
}
```

The _id_ field is autogenerated by the application, as well as the _dateCreated_ which is automatically set to the current date if it's not specified in the request. Also, for simplicity's sake we won’t include any tasks here.

Therefore, just specifying the _name_ field in our JSON should be enough:

```
{
  “name”: “project name”
}
```

If we use this JSON in the Postman request, a new entity will be created, and then retrieved with the generated _id_ and the corresponding _201 Created_ status code.

## The _@ResponseBody_ Annotation

This works similarly: **it indicates that the object we’re retrieving should be serialized as the raw response body**, since this is a REST API.

This is different from the typical behavior of a traditional Spring MVC application which will try to resolve a _View_ out of the response value.

**Even though we don’t have any _@ResponseBody_ annotation here, we’re still using it indirectly.**

As we mentioned previously, the _@RestController_ in a class serves as a shorthand for the _@Controller_ and the _@ResponseBody_ annotation.

And this last annotation in a type level is inherited by all its methods.

That’s why our _create_ method retrieves a JSON object with the fields corresponding to the _ProjectDto_ attributes we saw above.

## The _@ResponseStatus_ Annotation (extra)

The _@ResponseStatus_ annotation can be used in 2 ways:

-   during Error handling
-   on Controller methods

When we don’t need dynamic error responses, the easiest solution is to mark the _Exception_ class with _@ResponseStatus_:

```
@ResponseStatus(code = HttpStatus.BAD_REQUEST)
class CustomException extends RuntimeException {}
```

If this _CustomException_ is thrown from any handler method, then HTTP error code 400 will be returned to the client.

When _@ResponseStatus_ is used on controller methods, **it overrides the default status code (200) returned to the client** only if the annotated method completes successfully without throwing an _Exception_:

```
@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public ProjectDto create(@RequestBody ProjectDto newProject) {
    Project entity = convertToEntity(newProject);
    return this.convertToDto(this.projectService.save(entity));
}
```

In our example, the POST mapping that creates a new _Project_ will return status 201 - CREATED.

## Resources
- [Spring’s RequestBody and ResponseBody Annotations](https://www.baeldung.com/spring-request-response-body)
- [Http Message Converters with the Spring Framework](https://www.baeldung.com/spring-httpmessageconverter-rest)
- [Java Bean Validation Basics](https://www.baeldung.com/javax-validation)
- [Spring MVC Content Negotiation](https://www.baeldung.com/spring-mvc-content-negotiation-json-xml)
