# Centralized Configuration

## Introduction

**Completely separating the configuration information from the application code allows developers and operations to make changes to their configurations without going through a recompile process**. It also introduces complexity, because now developers have another artifact to manage and deploy with the application.

**Many developers turn to property files** to store their configuration information. Configuring your application in these files becomes a simple task, so easy that most developers never do more than placing their configuration file under source control.

**This approach might work with a small number of applications, but it quickly falls apart when dealing with cloud-based applications that can contain hundreds of microservices**, where each microservice might have multiple service instances running.

To avoid this catastrophic scenario, as a best practice for cloud-based microservices development, we should consider the following:
* Completely separate the configuration of an application from the actual code being deployed.
* Build immutable application images that never change as these are promoted towards production environments.
* Inject configuration data at service startup through either environment variables or a centralized repository.

![](images/m6-microservice-lifecycle.png)

## Configuration management architecture

![](images/m6-centralized-configuration.png)

1. When a microservice instance comes up, it calls a service endpoint to read its configuration information, which is specific to the environment it’s operating in. The connection information for the configuration management (connection credentials, service endpoint, ...) is passed into to the microservice as it starts.
2. The actual configuration resides in a repository. Based on the implementation of your configuration repository, you can choose different ways to hold your configuration data. This can include files under source control, relational databases, key-value data stores, etc. 
3. The actual management of the application configuration data occurs independently of how the application is deployed. Changes to configuration management are typically handled through the build and deployment pipeline, where modifications can be tagged with version information and deployed
through the different environments (development, staging, production, and so forth). 
4. When the configuration management changes, the services that use that application configuration data must be notified of the alteration and refresh their copy of the application data.

## Key principles
* **Segregate**: We need to completely separate the service configuration information from the actual physical deployment of a service. In fact, application configuration shouldn’t be deployed with the service instance. Instead, configuration information should either be passed as environment variables to the starting service or read from a centralized repository when the service starts.
* **Abstract**: We also need to abstract access to configuration data behind a service interface. Instead of writing code that directly reads the service repository, whether file-based or a JDBC database, we should use a REST-based JSON service to retrieve the application’s configuration data.
* **Centralize**: Because a cloud-based application might literally have hundreds of services, it’s critical to minimize the number of different repositories used to hold configuration data. Centralize your application configuration into as few repositories as possible.
* **Harden**: Because your application configuration information is going to be completely segregated from your deployed service and centralized, it’s critical that the solution you utilize and implement be highly available and redundant.

## Implementation choices

[etcd](https://github.com/etcd-io/etcd) - Written in Go, used as Kubernetes' backing store for all cluster data. Used for service discovery and key-value management. Uses the raft protocol (https://raft.github.io/) for its distributed computing model.

* Very fast and scalable
* Distributable
* Command-line driven
* Easy to use and set up

[HashiCorp Consul](https://developer.hashicorp.com/consul) - Similar to etcd but uses a different algorithm for its distributed computing model.

* Fast
* Offers native service discovery with the option to integrate directly with DNS
* Doesn’t offer client dynamic refresh out of the box

[Apache Zookeeper](https://zookeeper.apache.org/) - Offers distributed locking capabilities. Often used as a configuration management solution for accessing key-value data.

* Oldest, most battle-tested of the solutions 
* Most complex to use. Can be used for configuration management, but consider only if you’re already using it in other pieces of your architecture

[Spring Cloud Configuration Server](https://docs.spring.io/spring-cloud-config/docs/current/reference/html/) - Offers a general configuration management solution with different backends.

* Non-distributed key-value store
* Offers tight integration for Spring and non-Spring services
* Can use multiple backends for storing configuration data including filesystem, Consul, Git, Redis etc.

## Resources
- Spring Microservices in Action (Chapter 5)


